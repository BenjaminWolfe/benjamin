---
title: Python Modules from R
author: Benjamin Wolfe
date: '2020-05-18'
slug: []
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '2020-05-18T12:39:33-05:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
draft: true
source_extension: ".Rmd"
---

This is a draft post! Good lord please don't read it.

one thing I consistently struggled with when first learning Python from R was,
_“How the hell are the file structured?”_

Specifically, at the top of each file you see these `import` statements:

```python
import pandas as pd
from pathlib import Path
```

They're obviously similar to `library` statements in R—

```r
library(tidyverse)
library(signs)
```

—but how similar are they?
What are the differences?

One apparent difference I saw, for example,
was that you could `import` arbitrary files
from the same folder as the one you were in.
So is `import` more similar to a `source` statement in R?

Another thing that piqued my interest is just how Python _finds_ these files.
How does it know what you're talking about?
This is important to everything from file organization to workflow
to troubleshooting installation issues.
I know how it works in R, for example:

* To use `library`, you must have installed the package
  using one of our canonical methods:
  `install.packages()`, or `remotes::install_github()`, for example.
* To use `source`, you refer to the file
  by its path relative to the working directory,
  or use an absolute reference,
  or preferably use [Kirill Müller][krlmlr]'s [`here` package][here-here].

That may be a lot to remember for a beginner, come to think of it.
But for someone who's used R for a while it comes to be second nature.
So how does it work in Python?

It took me a bit to unravel the mysteries.
But once you pick up the way things work it all makes sense.
__Make this sentence better; even use it as a practical and specific intro to the next sections.__

## How Does `library` Work?

The best way to understand how `import` works in Python
is to start with a deeper dive into `library` in R.

See, when you run `library(package_name)`,
all it does is runs all the R files in a particular directory of that package.

![_a partial list of R files run when you load `ggplot2`_](ggplot_r_directory.png)

There are two things peculiar to this process, over that of sourcing scripts.
One is that package authors are very careful to write these files so that all they do is define functions.
The other is that when you `library` the file, those functions don't show up in the upper right panel of RStudio, the way they would if you `source`d the file.
They don't exist in what's called "the global environment."
Instead, they get their own "namespace," callable directly as `package_name::function()`.
And when you call `library(package_name)`, they just sit there magically in the background ready to be used.
(__Maybe relocate that sentence.__)
For a very simple example, see the R directory of my signs package.
It has only one R file, which has only two functions in it.
If you source that file, it will define those two functions, and they'll sit in your global environment, showing up in the upper right panel of RStudio.
If instead you run `install.packages("signs")` and `library(signs)`,
it will _also_ define those two functions, running the same code,
but they'll exist in their own portioned-off world, their own namespace,
and they won't show up in your defined functions.


* The whole `as pd` thing.
* The fact that there's `pip install`, and `conda install`,
  and virtual environments and everything,
  But at its very basic there's an `autoexec.pth` file,
  and python will look for files along that path.
  __Maybe look into `conda`, `venv`, and `renv`?__
* The fact that import is sort of a hybrid between `library` and `source`.
* The fact that in R you can use double-colon notation without even attaching the package,
  but I'm not sure that you can do that in Python.
  __(Worth checking.)__
  Maybe say perhaps it's because R has a dedicated operator
  that it can unambiguously do that.
* So in any case `import` then is actually just like `library`,
  in that you're running the file and anything created in it now lives in its own namespace.
* _But!_ you still have to refer to it by that namespace,
  which is great for both avoiding conflicts and for readability.
* But it's a little annoying, which is why you can also __alias__ a package,
  with `import pandas as pd`, which is just like aliasing in SQL
  (maybe show a SQL example with a simple join?).
* If there's a particular function you use all the time from a module,
  you can just import that function: `from itertools import repeat`.
* And for that matter you can blow the lid off and say `from itertools import *`,
  but that's widely advised against.
  Interesting that this is essentially what you're doing in R when you run `library(tidyverse)`.
  But the precision Python allows around imports makes it a bit muddy by contrast.
* Here's where you say: but the super loosy goosy flexibility of `import`
  is that even though you _feel_ like you're using a `library` statement,
  you can also just run it on the file next door,
  in the same directory, the way you would with `source`.
* So how does Python know where to look for an `import`?
  (See those notes.)
* Dot notation for importing within a folder.
* `__init__.py` so you don't have to do that.
  Maybe say wrapping with double underscores in Python
  is like leading with a dot in the Tidyverse;
  it's a way of saying "no one will actually do this, so let's use it for reserved names."

Maybe do virtual environments and such as an addendum!

I think I know how I'll write this! :boom:

----

Note to self… maybe make the examples have 4 scripts with toy code in them,
with 3 functions,
so I can split them into 2 folders in the Python part.

When you're coding in #rstats and you want to modularize your code,
there are roughly two ways to do it:

* one way when for scripts,
* and another for writing packages.

The way you do it for scripts is usually the first way most of us learn.
Say you have a project, and it lives in a folder called `my_r_project`.
In that project, you have 3 scripts,
`script_1.R`, `script_2.R`, and `script_3.R`,
and you're starting to notice that they tend to use the same two functions,
`hello()` and `world()`.

BLA BLA BLA process tell reader that you move them both into `fave_functions.R`
and then you replace them in `script_1.R`, `script_2.R`, and `script_3.R` with

```r
source("fave_functions.R")
```

And then those functions are available in the rest of it.
(Maybe note that it's available right there in the global environment,
shows up in the upper right of RStudio.)

If you're writing a package, it feels a little different…
you have your package directory…
and then in that you have a folder called `R` where all your code lives…
and you follow Hadley's advice:

> While you’re free to arrange functions into files as you wish,
> the two extremes are bad: don’t put all functions into one file
> and don’t put each function into its own separate file.
> (It’s OK if some files only contain one function,
> particularly if the function is large or has a lot of documentation.).
> File names should be meaningful and end in .R.

From here: http://r-pkgs.had.co.nz/r.html

And then you follow the rest of the advice in all the microtutorials on this,
and then you get to do the really cool thing of using `library(fave_functions)`
and using them in your code.

Of course, they now don't show up in the global environment in the upper right,
but you _can_ just write `hello()` and it'll work.

And even if you don't use `library(fave_functions)`, you can also use `fave_functions::hello()`.

BLA BLA BLA

Cool thing is they're just the same in Python.

You can put `fave_functions.py` in the same folder where you are
and then use `import fave_functions` and you're good.

Difference here though is that you still have to say `fave_functions.hello()`,
which is why most people would use `import fave_functions as ff`
and then just say `ff.hello()`.

And then, for packages, it's like this…
You make your package folder, called `fave_functions`
and then in it you can have any number of python files with functions in them.
And you use a file called `__init__.py` that looks like this:

```
from file1 import (fun1, fun2)
from file2 import (fun3)
```

And then in your code you do the same thing,
`import fave_functions as ff`.

So how does Python know where to look for this folder?
After all, in R you just use `install.packages()` and download it.
Well R itself, you may have noticed (and if you haven't you will at some point),
has its own install directory.
It varies by OS, but on a Mac for example it's `...`

And R only knows to look _there_ because it's on a variable called `.libPaths()`.
You can run that and see exactly where R looks for packages.
If the package is there, R will find it!
If it's not, then it won't.

It's very much the same with Python.
Python just doesn't distinguish so sharply between packages and plain old files.
So it _first_ looks in the directory you're in.
And it _then_ starts scanning through the autoexec path.
It's helpful to set that yourself by looking at {insert documentation here}.

So that's all there is to know!

* Python isn't that different from R in this regard.
* Python treats plain files and packages very similarly.
* Python also still makes you qualify your references.
* Bonus: Modularizing code isn't that different even in R
  whether you're just writing scripts or developing a package.

FWIW maybe note that it's kind of cool to use pd.DataFrame etc.
It makes it really clear where everything's coming from.

Also remember the file in R where it says what all the imports are?

[krlmlr]: https://twitter.com/krlmlr
[here-here]: https://github.com/jennybc/here_here

